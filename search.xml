<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Stream</title>
      <link href="/2018/09/09/stream/"/>
      <url>/2018/09/09/stream/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据，是支持顺序和并行聚合操作的元素序列。除了Stream(对象引用的流)之外，还有IntStream、LongStream和DoubleStream的对于基本数据类型的stream，所有这些都被称为“streams”。</p><blockquote><ol><li>数据源：数组，集合，生成器函数，I / O通道</li><li>处理聚合操作：filter，map，sort等<a id="more"></a></li><li>intermediate:中间业务操作，惰性化处理。零个或多个中间业务主要目的是将流转换成另一个流，如：filter，map。然后交给下一个操作。下一个操作有可能为intermediate，也有可能为Terminal</li><li>Terminal：源数据的计算仅在终端操作启动时执行，源元素仅在需要时使用</li><li>一般流操作接受函数式接口的参数，即lambda表达式。</li><li>流不提供直接访问或操纵其元素的手段，而是涉及声明性地描述它们的源以及将在该源上聚合执行的计算操作。不能像集合一样对元素的有效管理和访问</li><li>流管道可以顺序执行或并行执行</li></ol></blockquote><h2 id="流的使用"><a href="#流的使用" class="headerlink" title="流的使用"></a>流的使用</h2><p>&emsp;&emsp;Stream中的很多方法的参数包含函数式接口，即支持lambda表达式<br>数据准备：</p><blockquote><p>下方很多示例都依赖于此数据准备<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer userId;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">  <span class="keyword">private</span> Integer weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;User&gt; <span class="title">buildUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User xiaoming = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"xiaoming"</span>, <span class="number">28</span>, <span class="number">60</span>);</span><br><span class="line">    User xiaohong = <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"xiaohong"</span>, <span class="number">17</span>, <span class="number">60</span>);</span><br><span class="line">    User xiaohuang = <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"xiaohuang"</span>, <span class="number">21</span>, <span class="number">60</span>);</span><br><span class="line">    User xiaolan = <span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">"xiaolan"</span>, <span class="number">25</span>, <span class="number">60</span>);</span><br><span class="line">    User xiaoqing = <span class="keyword">new</span> User(<span class="number">5</span>, <span class="string">"xiaoqing"</span>, <span class="number">19</span>, <span class="number">60</span>);</span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    userList.add(xiaoming);</span><br><span class="line">    userList.add(xiaohong);</span><br><span class="line">    userList.add(xiaohuang);</span><br><span class="line">    userList.add(xiaolan);</span><br><span class="line">    userList.add(xiaoqing);</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(<span class="keyword">new</span> Streams.StreamBuilderImpl&lt;&gt;(t), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;Stream提供了两个重载方法来生成流。集合等(如：Collection、List)提供了stream()方法来构造流。还可以通过java.util.Spliterator接口自己来构建流<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line">Stream stream = Stream.of(<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>);</span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">String[] arr = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">stream = Stream.of(arr);</span><br><span class="line"><span class="comment">// 集合</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(arr);</span><br><span class="line">stream = list.stream();</span><br><span class="line">stream = Stream.of(list); <span class="comment">// 和一行是有区别的。这里会把整个list当成一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成10个随机数</span></span><br><span class="line">Random seed = <span class="keyword">new</span> Random();</span><br><span class="line">Supplier&lt;Integer&gt; random = () -&gt; seed.nextInt();</span><br><span class="line">Stream.generate(random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成连续有序的10个数字</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><p>&emsp;generate方法返回无限顺序无序流，其中每个元素由提供的Supplier生成。一般用于常量、随机数流等。方法的参数是supplier接口的实例，可以自己实现Supplier接口来生成流。<br>&emsp;iterate方法通过定义初始元素及运算函数返回一个连续有序的的无限流。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>&emsp;&emsp;返回由与给定谓词匹配的流的元素组成的流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream的filter</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter方法参数类型</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;filter方法的参数为函数式接口java.util.function.Predicate。接口的抽象方法为返回值类型为boolean的test方法。可以看出filter的过滤依赖于test方法。<br>&emsp;示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 年龄大于20的User </span></span><br><span class="line">userList.stream().filter(user -&gt; user.getAge() &gt; <span class="number">20</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><p>输出:</p><blockquote><p>User{userId=1, name=’xiaoming’, age=28, weight=60}<br>User{userId=3, name=’xiaohuang’, age=21, weight=60}<br>User{userId=4, name=’xiaolan’, age=25, weight=60}  </p></blockquote><p>&emsp;lambda表达式代码块里可写任意的过滤规则，返回true。对应的元素则过滤出来，注意此处是过滤出来留下不是过滤掉，返回false，对应的元素不会留下。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>&emsp;返回一个流，该流包含将给定函数应用于此流的元素的结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;map方法的参数为函数式接口java.util.function.Function。接口的抽象方法为apply方法。<br>&emsp;示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有user的name大写并输出name</span></span><br><span class="line">userList.stream().map(user -&gt; user.getName().toUpperCase()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有user的name大写并输出user</span></span><br><span class="line">userList.stream().map(user -&gt; &#123;</span><br><span class="line">  user.setName(user.getName().toUpperCase());</span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><p>&emsp;map方法返回的还是一个stream。对集合中元素进行一次处理后，返回的具体元素取决于lambda表达式里的返回值。如上示例所示，两个返回值不同，一个输出的是所有大写后的name，一个输出是name被大写后的所有user。<br>&emsp;<strong>mapToInt、mapToLong、mapToDouble</strong>方法返回的是对应的原始类型的 <strong>IntStream、LongStream、DoubleStream</strong>。拆装箱在一定数据量下是非常耗时的。所以在针对于基本数据类型处理时，需要用对应的stream,以免除自动装箱/拆箱的额外消耗。<strong>IntStream、LongStream、DoubleStream</strong>还提供了用于基本数据类型计算的函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求年龄的平均值</span></span><br><span class="line">OptionalDouble average = userList.stream().mapToInt(user -&gt; Integer.valueOf(user.getAge())).average();</span><br><span class="line">System.out.println(average.getAsDouble());</span><br><span class="line"><span class="comment">// 求年龄的和</span></span><br><span class="line"><span class="keyword">int</span> sum = userList.stream().mapToInt(user -&gt; Integer.valueOf(user.getAge())).sum();</span><br><span class="line">System.out.println(sum);</span><br><span class="line"><span class="comment">// 求年龄的最大值</span></span><br><span class="line">OptionalInt max = userList.stream().mapToInt(user -&gt; Integer.valueOf(user.getAge())).max();</span><br><span class="line">System.out.println(max.getAsInt());</span><br></pre></td></tr></table></figure></p><p>&emsp;<strong>flatmap</strong><br>&emsp;返回一个流，该流由将提供的映射函数应用于每个元素所生成的映射流的内容替换此流的每个元素的结果组成。其每个元素转换得到的是Stream对象，会把子Stream中的元素压缩到父集合中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单词去重</span></span><br><span class="line">String[] words = <span class="keyword">new</span> String[]&#123;<span class="string">"Hello"</span>,<span class="string">"World"</span>&#125;;</span><br><span class="line">List&lt;String[]&gt; arrList = Arrays.stream(words)</span><br><span class="line">    .map(word -&gt; word.split(<span class="string">""</span>))</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">arrList.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; collect = Arrays.stream(words)</span><br><span class="line">    .map(word -&gt; word.split(<span class="string">""</span>))</span><br><span class="line">    .flatMap(Arrays::stream)</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">collect.forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><p>&emsp;请注意上述示例两句代码返回的类型是不同的。flatmap以扁平化方式来处理流。可以将一个二维的数组或集合映射成一个一维的数据来处理。比map方法映射的更深一层。stream同样提供了针对基本数据类型的flatmap方法：<strong>flatMapToInt、flatMapToLong、flatMapToDouble</strong>。</p><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>&emsp;返回Object.equals(Object)由此流的不同元素（根据 ）组成的流。<br>&emsp;对于有序流，不同元素的选择是稳定的（对于重复元素，保留在遇到顺序中首先出现的元素。）对于无序流，不进行稳定性保证。保持distinct()并行管道的稳定性相对昂贵（要求操作充当完全屏障，具有大量缓冲开销），并且通常不需要稳定性。如果您的情境的语义允许，使用无序流源（如generate(Supplier)）或删除排序约束BaseStream.unordered()可能会导致distinct()并行管道的执行效率显着提高。如果需要与遇到顺序的一致性，并且您distinct()在并行管道中遇到性能不佳或内存利用率，则切换到顺序执行BaseStream.sequential()可能会提高性能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串去重</span></span><br><span class="line">List&lt;String&gt; strList = Arrays.asList(<span class="string">"h"</span>,<span class="string">"e"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"o"</span>,<span class="string">"w"</span>,<span class="string">"o"</span>,<span class="string">"r"</span>,<span class="string">"l"</span>,<span class="string">"d"</span>);</span><br><span class="line">strList.stream().distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据对应key对对象去重</span></span><br><span class="line">userList.stream().filter(distinctByKey(user -&gt; user.getUserId()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">distinctByKey</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Object&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">    Map&lt;Object, Boolean&gt; seen = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;distinct去重是根据equals方法比较来的。而对于对象，需要重写equals方法才能达到去重的目的。选定特定的key进行去重，可以自定义方法distinctByKey来去重，distinctByKey去重依赖于对filter方法的应用及Map接口的putIfAbsent方法的应用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    V v = get(key);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">        v = put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;putIfAbsent方法和put方法的区别是，给定key存在时则返回key映射的value，并不就行替换。给定key不存在则返回null</p><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;stream提供两个重载方法来处理排序。一个是按照自然顺序排序，同时流的元素要实现Comparable接口，否则会抛出java.lang.ClassCastException异常；一个时需要自己来定义比较器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串排序</span></span><br><span class="line">List&lt;String&gt; strList = Arrays.asList(<span class="string">"h"</span>,<span class="string">"e"</span>,<span class="string">"l"</span>,<span class="string">"l"</span>,<span class="string">"o"</span>,<span class="string">"w"</span>,<span class="string">"o"</span>,<span class="string">"r"</span>,<span class="string">"l"</span>,<span class="string">"d"</span>);</span><br><span class="line">strList.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会抛出java.lang.ClassCastException异常</span></span><br><span class="line">userList.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据user的年龄排序</span></span><br><span class="line">userList.stream().sorted((o1, o2) -&gt; o1.getAge() - o2.getAge()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出第一个元素</span></span><br><span class="line">Optional&lt;User&gt; first = userList.stream().sorted((o1, o2) -&gt; o1.getAge() - o2.getAge()).findFirst();</span><br><span class="line">System.out.println(first);</span><br></pre></td></tr></table></figure></p><p>&emsp;findFirst方法返回Optional类型的对象来描述此流的第一个元素。如果流没有经过排序，则可以返回任何元素。同样有findAny方法，返回流中不确定的某个元素</p><h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><p>&emsp;返回一个由该流的元素组成的流，并在每个元素上执行提供的操作。此方法主要用于支持调试，您希望在元素流经管道中的某个点时查看这些元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line">    .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line">    .peek(e -&gt; System.out.println(<span class="string">"Filtered value: "</span> + e))</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .peek(e -&gt; System.out.println(<span class="string">"Mapped value: "</span> + e))</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p><p>输出</p><blockquote><p>Filtered value: three<br>Mapped value: THREE<br>Filtered value: four<br>Mapped value: FOUR  </p></blockquote><p>&emsp;可以看出peek方法可以查看到每个通过流管道的元素。</p><h3 id="limit-skip"><a href="#limit-skip" class="headerlink" title="limit/skip"></a>limit/skip</h3><p>&emsp;limit返回由此流的元素组成的流，截断为不超过maxSize长度。skip为返回由此流的其余元素组成的流。如果此流包含的n元素少于元素，则将返回空流。即limit返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userList.stream().limit(<span class="number">1</span>).skip(<span class="number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><p>输出</p><blockquote><p>User{userId=2, name=’xiaohong’, age=17, weight=60}<br>User{userId=3, name=’xiaohuang’, age=21, weight=60} </p></blockquote><p>&emsp;输出了第2、3两个元素，limit和skip结合使用可对数据源进行截取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// limit方法参数不支持负数，会抛出IllegalArgumentException</span></span><br><span class="line">userList.stream().limit(-<span class="number">2</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><h3 id="forEach-forEachOrdered"><a href="#forEach-forEachOrdered" class="headerlink" title="forEach/forEachOrdered"></a>forEach/forEachOrdered</h3><p>&emsp;两个函数都是对集合的流，进行遍历操作，是属于内部迭代。forEachOrdered是按照已有顺序就行遍历。forEach是并行处理的，效率更好。</p><h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><p>&emsp;流的转换，转换成数组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] toArray();</span><br><span class="line"><span class="comment">// 参数为一个产生所需类型和提供长度的新数组的函数</span></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br></pre></td></tr></table></figure></p><p>&emsp;提供了两个转换数组的重载方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"abc"</span>,<span class="string">""</span>,<span class="string">"bc"</span>,<span class="string">""</span>,<span class="string">"d"</span>,<span class="string">"ef"</span>);</span><br><span class="line">String[] strArr = list.stream().filter(StringUtils::isNotEmpty).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">System.out.println(Arrays.toString(strArr));</span><br></pre></td></tr></table></figure></p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>&emsp;使用提供的标识值和关联累积函数对流的元素执行一个规约，这个方法的主要作用是把 Stream 元素组合起来。它提供一个标识值，然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = integers.reduce(<span class="number">0</span>, (a, b) -&gt; a+b);</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">Integer sum = integers.reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">Integer sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer integer : Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">  sum = sum + integer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串连接，concat = "abcd"</span></span><br><span class="line">String concat = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>).reduce(<span class="string">""</span>, String::concat); </span><br><span class="line"><span class="comment">// 求和</span></span><br><span class="line">Optional optional = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum);</span><br><span class="line">System.out.println(optional.get());</span><br></pre></td></tr></table></figure></p><p>&emsp;请注意上述代码最后一个求和，使用的reduce没有起始值的重载方法，返回的Optional</p><h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><blockquote><p>anyMatch: 返回该流中是否有元素符合Predicate。如果是返回true<br>allMatch: 返回该流中是否所有元素符合Predicate。如果是返回true<br>noneMatch: 返回该流中是否所有元素不符合Predicate。如果是返回true<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否有用户的年龄大于25，true</span></span><br><span class="line">userList.stream().anyMatch(user -&gt; user.getAge() &gt; <span class="number">25</span>);</span><br><span class="line"><span class="comment">// 是否所有用户的年龄大于25，false</span></span><br><span class="line">userList.stream().allMatch(user -&gt; user.getAge() &gt; <span class="number">25</span>);</span><br><span class="line"><span class="comment">// 是否没有用户的年龄大约100，true</span></span><br><span class="line">userList.stream().noneMatch(user -&gt; user.getAge() &gt; <span class="number">100</span>);</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p>&emsp;对流元素就行reduction操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到user集合中所有用户的id</span></span><br><span class="line">List&lt;Integer&gt; userIdList = userList.stream().map(User::getUserId).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 以user的年龄进行分组</span></span><br><span class="line">Map&lt;Integer, List&lt;User&gt;&gt; userGroups = userList.stream().collect(Collectors.groupingBy(User::getAge));</span><br><span class="line"><span class="comment">// 未成年人和成年人分组</span></span><br><span class="line">Map&lt;Boolean, List&lt;User&gt;&gt; collect = userList.stream().collect(Collectors.partitioningBy(user -&gt; user.getAge() &gt; <span class="number">18</span>));</span><br><span class="line"><span class="comment">// key为id，value：user。</span></span><br><span class="line">Map&lt;Integer, User&gt; collect = userList.stream().collect(Collectors.toMap(User::getUserId, user -&gt; user));</span><br><span class="line"><span class="comment">// key为id，value：name</span></span><br><span class="line">Map&lt;Integer, String&gt; collect = userList.stream().collect(Collectors.toMap(User::getUserId, User::getName));</span><br></pre></td></tr></table></figure></p><p>&emsp;toMap方法可以根据要求任意组装map。有两个参数，第一个参数为map的key，不允许重复。否则会抛出java.lang.IllegalStateException: Duplicate key…………</p><h3 id="parallel"><a href="#parallel" class="headerlink" title="parallel"></a>parallel</h3><p>&emsp;上面的例子基本都是串行流，即都是单线程执行的。stream还提供了并行流，即多线程执行操作。串行和并行流功能上并无差别，唯一差别在于单线程还是多线程执行流的遍历处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并行流</span></span><br><span class="line">userList.parallelStream(); <span class="comment">// 串行流为：userList.stream()</span></span><br><span class="line">Stream.of(<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>).parallel();</span><br></pre></td></tr></table></figure></p><p>&emsp;stream对于并行流只是对处理类AbstractPipeline中属性parallel赋值为true。从stream角度来看功能并无差别。parallel为true。AbstractPipeline会通过fork/join的方式来进行并行处理<br>&emsp;像limit、peek等方法在有序的并行流上使用可能会影响效率。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
            <tag> stream </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lambda表达式</title>
      <link href="/2018/09/05/lambda/"/>
      <url>/2018/09/05/lambda/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;“Lambda 表达式”(lambda expression)是一个匿名函数<br>&emsp;&emsp;Java 8的一个大亮点是引入Lambda表达式，使用它设计的代码会更加简洁。当开发者在编写Lambda表达式时，也会随之被编译成一个函数式接口。</p><p>&emsp;&emsp;不采用Lambda的老方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Runnable r1 = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Running without Lambda"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>&emsp;&emsp;使用Lambda：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runnable r2 = ()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"Running from Lambda"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;正如所看到的，使用Lambda表达式不仅让代码变的简单、而且可读、最重要的是代码量也随之减少很多。然而，在某种程度上，这些功能在Scala等这些JVM语言里已经被广泛使用。<br><br>Lambda表达式的语法<br>(parameters) -&gt; expression<br>或<br>(parameters) -&gt;{ statements; }<br><br>lambda常见写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不传参数,返回值为 5  </span></span><br><span class="line">() -&gt; <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值  </span></span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和  </span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 5. 接受一个 string 类型参数,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure></p><p><strong>实例：</strong><br>数据准备：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer userId;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">  <span class="keyword">private</span> Integer weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;User&gt; <span class="title">buildUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User xiaoming = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"xiaoming"</span>, <span class="number">28</span>, <span class="number">60</span>);</span><br><span class="line">    User xiaohong = <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"xiaohong"</span>, <span class="number">22</span>, <span class="number">60</span>);</span><br><span class="line">    User xiaohuang = <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"xiaohuang"</span>, <span class="number">21</span>, <span class="number">60</span>);</span><br><span class="line">    User xiaolan = <span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">"xiaolan"</span>, <span class="number">25</span>, <span class="number">60</span>);</span><br><span class="line">    User xiaoqing = <span class="keyword">new</span> User(<span class="number">5</span>, <span class="string">"xiaoqing"</span>, <span class="number">19</span>, <span class="number">60</span>);</span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    userList.add(xiaoming);</span><br><span class="line">    userList.add(xiaohong);</span><br><span class="line">    userList.add(xiaohuang);</span><br><span class="line">    userList.add(xiaolan);</span><br><span class="line">    userList.add(xiaoqing);</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环遍历list普通写法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">normalLoopList</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">    System.out.println(user); <span class="comment">// 已重写toString方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历list，lambda写法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lambdaLoopList</span><span class="params">(List&lt;User&gt; userList)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//userList.forEach(user -&gt; System.out.println(user)); // 一般写法</span></span><br><span class="line">  userList.forEach(System.out::println); <span class="comment">// 精简写法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list排序普通写法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">normalSortUserByAge</span><span class="params">(List&lt;User&gt; userList)</span></span>&#123;</span><br><span class="line">  Collections.sort(userList, <span class="keyword">new</span> Comparator&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User o1, User o2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  normalLoopList(userList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list排序lambda写法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lambdaSortUserByAge</span><span class="params">(List&lt;User&gt; userList)</span></span>&#123;</span><br><span class="line">  Collections.sort(userList, (o1, o2) -&gt; o1.getAge() - o2.getAge());</span><br><span class="line">  lambdaLoopList(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上述例子，lambda表达式可以把代码精简到一行。<br><strong>注：</strong></p><blockquote><p>:: 为java方法引用的标准形式，格式为：类名::方法名，对象::方法名<br>注意是方法名，后面不能加”()”。一般用作lambda表达式  </p></blockquote><p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user -&gt; System.out.println(user)  等价于  System.out::println</span><br><span class="line">() -&gt; <span class="keyword">new</span> ArrayList()  等价于  ArrayList::<span class="keyword">new</span></span><br></pre></td></tr></table></figure></p><h2 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h2><p>&emsp;&emsp;标注为FunctionalInterface的接口被称为函数式接口，该接口只能定义一个抽象方法。如果一个接口只有一个方法，则编译器会认为这就是一个函数式接口。增加了 <strong>@FunctionalInterface</strong> 编辑器会进行编译校验。函数式接口要注意以下几点：</p><blockquote><ol><li>有且仅有一个抽象方法</li><li>允许定义default方法，接口中定义default方法为java8新特性</li><li>允许定义静态方法</li><li>允许定义重写从父类Object继承来的方法</li><li>注解不是必须得，加上编译器校验当前接口是否是函数式接口，若不是，则会编译报错</li></ol></blockquote><p><strong>任何可以接受一个函数式接口实例的地方，都可以用Lambda表达式。</strong> <br>上述例子中集合遍历、集合排序的方法源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* List接口中的default方法</span></span><br><span class="line"><span class="comment">* Consumer为java8提供的函数式接口，并使用了<span class="doctag">@FunctionalInterface</span>注解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Collections类的静态方法</span></span><br><span class="line"><span class="comment">* Comparator使用了<span class="doctag">@FunctionalInterface</span>注解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    list.sort(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;java8新提供的java.util.Function包下都为使用@FunctionalInterface注解的函数式接口。java8新特性stream也借助lambda及函数式接口。接口中的抽象方法有的是有返回值的，如java.util.function.Predicate<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Stream的filter方法参数即为Predicate接口。filter能对流进行过滤依赖于Predicate的test方法。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>定风波</title>
      <link href="/2018/08/31/first/"/>
      <url>/2018/08/31/first/</url>
      <content type="html"><![CDATA[<h2 id="一蓑烟雨任平生"><a href="#一蓑烟雨任平生" class="headerlink" title="一蓑烟雨任平生"></a>一蓑烟雨任平生</h2><p><center><strong>定风波</strong></center></p><p><center>苏轼</center></p><blockquote><p>莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。<br>料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴</p></blockquote>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗词 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>热爱生命</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<center>作者：汪国真</center><br><center>我不去想是否能够成功</center><center>既然选择了远方</center><center>便只顾风雨兼程</center><br><center>我不去想能否赢得爱情</center><center>既然钟情于玫瑰</center><center>就勇敢地吐露真诚</center><br><center>我不去想身后会不会袭来寒风冷雨</center><center>既然目标是地平线</center><center>留给世界的只能是背影</center><br><center>我不去想未来是平坦还是泥泞</center><center>只要热爱生命</center><center>一切，都在意料之中</center>]]></content>
    </entry>
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>随笔</title>
      <link href="/life/index.html"/>
      <url>/life/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>日志</title>
      <link href="/schedule/index.html"/>
      <url>/schedule/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
